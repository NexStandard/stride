// Copyright (c) .NET Foundation and Contributors (https://dotnetfoundation.org/ & https://stride3d.net) and Silicon Studio Corp. (https://www.siliconstudio.co.jp)
// Distributed under the MIT license. See the LICENSE.md file in the project root for more information.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Stride.Core.Assets;
using Stride.Core.Assets.Editor.ViewModel;
using Stride.Core.Extensions;
using Stride.Core.Presentation.Collections;
using Stride.Assets.Presentation.ViewModel;
using Stride.Assets.Scripts;

namespace Stride.Assets.Presentation.AssetEditors.VisualScriptEditor
{
    public partial class VisualScriptEditorViewModel
    {
        /// <summary>
        /// The list of diagnostics generated by background compilation.
        /// </summary>
        public ObservableList<Diagnostic> Diagnostics { get; } = new ObservableList<Diagnostic>();

        private async void Session_AssetPropertiesChanged(object sender, AssetChangedEventArgs e)
        {
            // Only continue if there was changes in this asset
            if (!e.Assets.Contains(Asset))
                return;

            await TriggerBackgroundCompilation();
        }

        private async Task TriggerBackgroundCompilation()
        {
        }

        #region Overridable helpers taken from Roslyn AbstractOverrideCompletionProvider
        private static void AddOverridableMembers(List<ISymbol> result, INamedTypeSymbol containingType, INamedTypeSymbol type)
        {
            foreach (var member in type.GetMembers())
            {
                if (IsOverridable(member, containingType))
                {
                    result.Add(member);
                }
            }
        }

        private static void RemoveOverriddenMembers(List<ISymbol> result, INamedTypeSymbol containingType)
        {
            foreach (var member in containingType.GetMembers())
            {
                var overriddenMember = member.OverriddenMember();
                if (overriddenMember != null)
                {
                    result.Remove(overriddenMember);
                }
            }
        }

        private static bool IsOverridable(ISymbol member, INamedTypeSymbol containingType)
        {
            if (member.IsAbstract || member.IsVirtual || member.IsOverride)
            {
                if (member.IsSealed)
                {
                    return false;
                }

                // This goes quite deep (lot of code to copy from Roslyn), currenlty ignored
                //if (!member.IsAccessibleWithin(containingType))
                //{
                //    return false;
                //}

                switch (member.Kind)
                {
                    case SymbolKind.Event:
                        return true;
                    case SymbolKind.Method:
                        return ((IMethodSymbol)member).MethodKind == MethodKind.Ordinary;
                    case SymbolKind.Property:
                        return !((IPropertySymbol)member).IsWithEvents;
                }
            }

            return false;
        }
        #endregion

        public struct Diagnostic
        {
            public Microsoft.CodeAnalysis.Diagnostic RoslynDiagnostic { get; set; }
            public Guid? BlockId { get; set; }
            public Guid? LinkId { get; set; }
        }
    }
}
